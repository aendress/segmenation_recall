if (ANALYZED.DATA.SETS["TESTABLE"]){
dat.recall.tstbl.m <-
dat.all.recall.items.tstbl.with.candidates %>%
#mutate_at (vars(starts_with("is_"),starts_with("has_")), as.logical) %>%
mutate (across (starts_with("is_") | starts_with("has_"), as.logical)) %>%
# For compatibility with the city data set
rename (subj = filename,
Age = age,
Gender = sex,
streamType = mySegmentationCond,
correct_segm = correct) %>%
# We have the following column in the city data set
group_by(subj, Age, Gender, lang, streamType, correct_segm) %>%
#        summarize_at (vars(n_syllables:average_bw_tp), mean, na.rm = TRUE)
summarize (
n.items = n(),
n.syll = mean (n_syllables),
# Number and proportion (among all responses) of words
n.words = sum (is_word),
p.words = mean (is_word),
n.words.or.multiple = sum (is_word | is_multiple_words),
p.words.or.multiple = mean (is_word | is_multiple_words),
# Number and proportion (among all responses) of part-words
n.part.words = sum (is_part_word),
p.part.words = mean (is_part_word),
n.part.words.or.multiple = sum (is_part_word | is_multiple_part_words),
p.part.words.or.multiple = mean (is_part_word | is_multiple_part_words),
# Proportion of Words among Words and Part-Words (or multiples thereof)
p.words.part.words = sum (is_word) / sum (is_word | is_part_word),
p.words.part.words.or.multiple = sum (is_word | is_multiple_words) /
sum (is_word | is_multiple_words | is_part_word | is_multiple_part_words),
# Number and proportion (among all responses) of high and low TP chunk
n.high.tp.chunk = sum (is_high_tp_chunk),
p.high.tp.chunk = mean (is_high_tp_chunk),
n.low.tp.chunk = sum (is_low_tp_chunk),
p.low.tp.chunk = mean (is_low_tp_chunk),
# Proportion of high-TP chunks among high and low-TP chunks
p.high.tp.chunk.low.tp.chunk = sum (is_high_tp_chunk) /
sum (is_high_tp_chunk | is_low_tp_chunk),
# Average forward TPs and difference from expected TP
average_fw_tp = mean (average_fw_tp, na.rm = TRUE),
average_fw_tp_d_actual_expected = mean (average_fw_tp - expected_fw_tp, na.rm = TRUE),
average_bw_tp = mean (average_bw_tp, na.rm = TRUE),
# Proportion of items with syllables in correct postions
p.correct.initial.syll = mean (has_correct_initial_syllable),
p.correct.final.syll = mean (has_correct_final_syllable),
p.correct.initial.or.final.syll = mean (has_correct_initial_syllable | has_correct_final_syllable)
)
# These are counts that are significantly above zero
dat.recall.tstbl.m.selected.vars.by.wilcox.df <-
dat.recall.tstbl.m %>%
group_by(streamType) %>%
summarize_at (vars(starts_with("n.")), function (X) wilcox.test (X, alternative = "greater")$p.value) %>%
remove_rownames %>%
column_to_rownames("streamType") %>%
t %>%
as.data.frame (row.names = row.names(.)) %>%
rownames_to_column("var") %>%
mutate (use = (continuous <= .05) | (segmented <= .05))
dat.recall.tstbl.m.selected.vars.by.wilcox <- dat.recall.tstbl.m.selected.vars.by.wilcox.df %>%
filter (use) %>%
pull ("var")
}
dat.column.meaning <- read.csv("helper/column_meanings.csv",
header = TRUE,
stringsAsFactors = FALSE,
comment.char = "#") %>%
column_to_rownames("colName")
# Attributes can be assigned as follows
# data.frame (n.items	= 1:10,
#             n.syll	= 1:10,
#             n.words = 1:10) %>%
#     add.column.attrib (dat.attrib) %>%
#     print.column.attrib
#The testable df has a language column the city one doesn't have
# name.comp <- cbind.na (sort (names (dat.recall.city.m)),
#           sort (names (dat.recall.tstbl.m))) %>%
#     data.frame
# save.data.frame(name.comp)
dat.recall.combined.m <- list ()
dat.recall.combined.m.selected.vars.by.wilcox <- list ()
if (ANALYZED.DATA.SETS["CITY"]){
dat.recall.combined.m <- c(dat.recall.combined.m,
list (dat.recall.city.m %>%
add_column (
data.set = "city",
.before = 1) %>%
add_column(
lang = NA,
.after = "Gender")))
dat.recall.combined.m.selected.vars.by.wilcox <- c(
dat.recall.combined.m.selected.vars.by.wilcox,
list (city = dat.recall.city.m.selected.vars.by.wilcox)
)
}
if (ANALYZED.DATA.SETS["TESTABLE"]){
dat.recall.combined.m <- c(dat.recall.combined.m,
list (dat.recall.tstbl.m %>%
add_column(
data.set = "testable",
.before  = 1)))
dat.recall.combined.m.selected.vars.by.wilcox <- c(
dat.recall.combined.m.selected.vars.by.wilcox,
list (testable = dat.recall.tstbl.m.selected.vars.by.wilcox))
}
dat.recall.combined.m <- bind_rows (dat.recall.combined.m) %>%
as.data.frame %>%
add.column.attrib (dat.column.meaning)
dat.recall.combined.m %>%
print.column.attrib %>%
filter (!is.na (meaning)) %>%
kable (caption="Analyses performed for the vocalizations",
booktabs = TRUE) %>%
kable_styling(latex_options =
c("hold_position",
"scale_down"),
bootstrap_options = "striped")
# Check which outcomes differ across the strema types. Used unpaired
# test by default
dat.recall.combined.m.wilcox.by.streamType <-   dat.recall.combined.m %>%
ungroup %>%
mutate (streamType = factor (streamType)) %>%
group_by (data.set) %>%
summarize (across(correct_segm:p.correct.initial.or.final.syll,
~ wilcox.p.2sample (.x, streamType)))
dat.recall.combined.m2 <- dat.recall.combined.m %>%
group_by(data.set, streamType) %>%
summarize_at (vars(correct_segm:p.correct.initial.or.final.syll),
mean, na.rm = TRUE)
dat.recall.combined.m2 %>%
data.frame %>%
rbind (.,
cbind(streamType = "$p_{Wilcoxon}$",
dat.recall.combined.m.wilcox.by.streamType)) %>%
remove_rownames %>%
arrange (data.set, desc(streamType)) %>%
mutate (rownames = paste0 (data.set, ".", streamType)) %>%
column_to_rownames("rownames") %>%
t %>%
knitr::kable (caption = "\\label{tab:recall_all_averages}All averages. The *p* value has been calculated from a paired Wilcoxon test across the familiarization conditions.", booktabs = T) %>%
kable_styling(latex_options =
c("hold_position",
"scale_down"),
bootstrap_options = "striped")
prepare.data.for.streamType.contrast <- function (dat = ., value.var, mu = 0) {
dat %>%
reshape2::dcast (data.set + subj ~ streamType, value.var = value.var) %>%
summarize (Continuous = wilcox.p(continuous, mu, TRUE),
Segmented = wilcox.p(segmented, mu, TRUE),
d = wilcox.test(continuous, segmented,
mu = 0,
paired = FALSE)$p.value
)
}
prepare.plot.for.streamType.contrast <- function (dat = ., x, y) {
dat %>%
ggplot (aes (x= {{x}}, y = {{y}})) +
# geom_boxplot (alpha=.5, fill="lightblue", outlier.shape = NA) +
geom_dotplot(binaxis = "y", stackdir = "center") +
geom_violin(alpha = 0,
fill = "#5588CC", col="#5588CC") +
stat_summary(fun.data=mean_sdl,
fun.args = list (mult=1),
geom="pointrange", color="#cc556f") +
facet_grid(data.set ~ ., scales = "free") +
theme_light (16) +
theme (axis.title.x = element_blank())
}
# Print later in common table with length
dat.recall.combined.m.n.items <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("n.items")
# Plot later together with length
plot.recall.combined.m.n.items <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, n.items) +
ylab ("# items")
# Print later in common table with number of items
dat.recall.combined.m.n.syll <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("n.syll")
# Plot later together with number of items
plot.recall.combined.m.n.syll <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, n.syll) +
ylab ("# syllables/item")
ggpubr::ggarrange (
plot.recall.combined.m.n.items,
plot.recall.combined.m.n.syll,
nrow = 1, ncol = 2,
#common.legend = TRUE, legend="bottom",
#legend.grob = plot.circle.combined.within.recency.legend,
labels = "auto")
dat.recall.combined.m.n.words <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("n.words.or.multiple")
dat.recall.combined.m.p.words <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("p.words.or.multiple")
plot.recall.combined.m.n.words <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, n.words.or.multiple) +
ylab ("# Words")
plot.recall.combined.m.p.words <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, p.words.or.multiple) +
ylab (TeX("\\frac{Words}{Productions}$"))
dat.recall.combined.m.n.part.words <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("n.part.words.or.multiple")
dat.recall.combined.m.p.part.words <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("p.part.words.or.multiple")
plot.recall.combined.m.n.part.words <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, n.part.words.or.multiple) +
ylab ("# Part-Words")
plot.recall.combined.m.p.part.words <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, p.part.words.or.multiple) +
ylab (TeX("\\frac{Part-Words}{Productions}$"))
dat.recall.combined.m.p.words.part.words <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("p.words.part.words.or.multiple", .5)
plot.recall.combined.m.p.word.part.words <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, p.words.part.words.or.multiple) +
ylab (TeX("\\frac{Words}{Words + Part-Words}$"))
ggpubr::ggarrange (
plot.recall.combined.m.n.words,
plot.recall.combined.m.p.words,
plot.recall.combined.m.n.part.words,
plot.recall.combined.m.p.part.words,
plot.recall.combined.m.p.word.part.words,
nrow = 3, ncol = 2,
#common.legend = TRUE, legend="bottom",
#legend.grob = plot.circle.combined.within.recency.legend,
labels = "auto")
dat.recall.combined.m.forward.tps <- dat.recall.combined.m %>%
# This is the TP for a random string
prepare.data.for.streamType.contrast("average_fw_tp", 1/12)
dat.recall.combined.m.forward.tps.actual.vs.expected <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("average_fw_tp_d_actual_expected", 0)
plot.recall.combined.m.forward.tps <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, average_fw_tp) +
ylab ("Forward TPs") +
geom_hline (yintercept = 1/12, lty = 3)
plot.recall.combined.m.forward.tps <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, average_fw_tp_d_actual_expected) +
ylab ("Actual - Expected Forward TPs")
dat.recall.combined.m.backward.tps <- dat.recall.combined.m %>%
# This is the TP for a random string
prepare.data.for.streamType.contrast("average_bw_tp", 1/12)
plot.recall.combined.m.backward.tps <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, average_bw_tp) +
ylab ("Backward TPs") +
geom_hline (yintercept = 1/12, lty = 3)
ggpubr::ggarrange (
plot.recall.combined.m.forward.tps,
plot.recall.combined.m.forward.tps,
plot.recall.combined.m.backward.tps,
nrow = 3, ncol = 1,
#common.legend = TRUE, legend="bottom",
#legend.grob = plot.circle.combined.within.recency.legend,
labels = "auto")
dat.recall.combined.m.n.high.tp.chunk <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("n.high.tp.chunk", 0)
dat.recall.combined.m.p.high.tp.chunk <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("p.high.tp.chunk", 0)
dat.recall.combined.m.n.low.tp.chunk <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("n.low.tp.chunk", 0)
dat.recall.combined.m.p.low.tp.chunk <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("p.low.tp.chunk", 0)
dat.recall.combined.m.p.high.tp.chunk.low.tp.chunk <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("p.high.tp.chunk.low.tp.chunk", 0.5)
plot.recall.combined.m.n.high.tp.chunk <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, n.high.tp.chunk) +
ylab ("# High TP Chunks")
plot.recall.combined.m.p.high.tp.chunk <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, p.high.tp.chunk) +
ylab (TeX("\\frac{High TP chunks}{Productions}$"))
plot.recall.combined.m.n.low.tp.chunk <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, n.low.tp.chunk) +
ylab ("# Low TP Chunks")
plot.recall.combined.m.p.low.tp.chunk <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, p.low.tp.chunk) +
ylab (TeX("\\frac{Low TP chunks}{Productions}$"))
plot.recall.combined.m.p.high.tp.chunk.low.tp.chunk <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, p.high.tp.chunk.low.tp.chunk) +
ylab (TeX("\\frac{High TP chunks}{High + Low TP chunks}$"))
ggpubr::ggarrange (
plot.recall.combined.m.n.high.tp.chunk,
plot.recall.combined.m.p.high.tp.chunk,
plot.recall.combined.m.n.low.tp.chunk,
plot.recall.combined.m.p.low.tp.chunk,
plot.recall.combined.m.p.high.tp.chunk.low.tp.chunk,
nrow = 3, ncol = 2,
#common.legend = TRUE, legend="bottom",
#legend.grob = plot.circle.combined.within.recency.legend,
labels = "auto")
dat.recall.combined.m.p.correct.initial.syll <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("p.correct.initial.syll", 4/12)
dat.recall.combined.m.p.correct.final.syll <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("p.correct.final.syll", 4/12)
dat.recall.combined.m.p.correct.initial.or.final.syll <- dat.recall.combined.m %>%
prepare.data.for.streamType.contrast("p.correct.initial.or.final.syll", 5/9)
plot.recall.combined.m.p.correct.initial.syll <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, p.correct.initial.syll) +
ylab (TeX("\\frac{# Correct Initial Syllables}{Productions}$")) +
geom_hline (yintercept = 4/12, lty = 3)
plot.recall.combined.m.p.correct.final.syll <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, p.correct.final.syll) +
ylab (TeX("\\frac{# Correct Final Syllables}{Productions}$")) +
geom_hline (yintercept = 4/12, lty = 3)
plot.recall.combined.m.p.correct.initial.or.final.syll <- dat.recall.combined.m %>%
prepare.plot.for.streamType.contrast (streamType, p.correct.initial.or.final.syll) +
ylab (TeX("\\frac{# Correct Initial Final Syllables}{Productions}$")) +
geom_hline (yintercept = 5/9, lty = 3)
ggpubr::ggarrange (
plot.recall.combined.m.p.correct.initial.syll,
plot.recall.combined.m.p.correct.final.syll,
plot.recall.combined.m.p.correct.initial.or.final.syll,
nrow = 3, ncol = 1,
#common.legend = TRUE, legend="bottom",
#legend.grob = plot.circle.combined.within.recency.legend,
labels = "auto")
dat.recall.combined.m.n.items.n.syll <-
bind_rows(
dat.recall.combined.m.n.items %>%
mutate (filter = "Number of items"),
dat.recall.combined.m.n.syll %>%
mutate (filter = "Number of syllables/item"),
dat.recall.combined.m.n.words %>%
mutate (filter = "Number of words"),
dat.recall.combined.m.n.words %>%
mutate (filter = "Proportion of words among vocalizations"),
dat.recall.combined.m.n.part.words %>%
mutate (filter = "Number of part-words"),
dat.recall.combined.m.n.part.words %>%
mutate (filter = "Proportion of part-words among vocalizations"),
dat.recall.combined.m.p.words.part.words %>%
mutate (filter = "Proportion of part-words among words and part-words" ),
dat.recall.combined.m.forward.tps %>%
mutate (filter = "Forward TPs"),
dat.recall.combined.m.forward.tps.actual.vs.expected %>%
mutate (filter = "Actual vs. Expected Forward TPs"),
dat.recall.combined.m.backward.tps %>%
mutate (filter = "Backward TPs"),
dat.recall.combined.m.n.high.tp.chunk %>%
mutate (filter = "Number of High TP chunks"),
dat.recall.combined.m.p.high.tp.chunk %>%
mutate (filter = "Proportion of High TP chunks among productions"),
dat.recall.combined.m.n.low.tp.chunk %>%
mutate (filter = "Number of Low TP chunks"),
dat.recall.combined.m.p.low.tp.chunk %>%
mutate (filter = "Number of Low TP chunks among productions"),
dat.recall.combined.m.p.high.tp.chunk.low.tp.chunk %>%
mutate (filter = "Proportion of High TP chunks among High and Low TP chunks"),
dat.recall.combined.m.p.correct.initial.syll %>%
mutate (filter = "Proportion of items with correct initial syllables"),
dat.recall.combined.m.p.correct.final.syll %>%
mutate (filter = "Proportion of items with correct final syllables"),
dat.recall.combined.m.p.correct.initial.or.final.syll %>%
mutate (filter = "Proportion of items with correct initial or final syllables")
)
dat.recall.combined.m.n.items.n.syll %>%
dplyr::select (-c("filter")) %>%
rename ("$p_{cont vs. segm}$"="d") %>%
kable (caption = "\\label{tab:recall_overall_results}Various analyses pertaining to the productions as well as test against their chances levels. Number of items produced, their numbers of syllables, number of words, number of part-words (chance level: 0), proportion  of words among productions, proportion of part-words among productions, proportion of words among words and part-words (chance level 50%), average forward TPs (chance level: 1/12), difference between positionally expected and actual TPs, average backward TPS. CHUNKS ", booktabs = TRUE, escape = FALSE) %>%
#     kable_styling() %>%
pack_rows(index = make.pack.index (dat.recall.combined.m.n.items.n.syll$filter))
xlsx::write.xlsx (dat.recall.city,
file="output/segmentation_recall_transcriptions_output.xlsx",
row.names=FALSE,
sheetName="complete",
append=FALSE)
dat.recall.city.m %>%
ungroup %>%
data.table::setDT(.) %>%
data.table::dcast (subj  + subjNum + subjInitials + Age + Gender ~ streamType,
value.var = names(.)[7:31]) %>%
data.table::setDF(.) %>%
xlsx::write.xlsx (.,
file="output/segmentation_recall_transcriptions_output.xlsx",
row.names=FALSE,
sheetName="means",
append=TRUE)
dat.recall.city
xlsx::write.xlsx (dat.recall.city,
file="output/segmentation_recall_transcriptions_output.xlsx",
row.names=FALSE,
sheetName="complete (city)",
append=FALSE)
xlsx::write.xlsx (dat.recall.tstbl,
file="output/segmentation_recall_transcriptions_output.xlsx",
row.names=FALSE,
sheetName="complete (tstbl)",
append=TRUE)
xlsx::write.xlsx (dat.recall.combined.m,
file="output/segmentation_recall_transcriptions_output.xlsx",
row.names=FALSE,
sheetName="means",
append=TRUE)
unlink('segmentation_recall_combined_cache', recursive = TRUE)
dat.recall.combined.m.n.items.n.syll <-
bind_rows(
dat.recall.combined.m.n.items %>%
mutate (filter = "Number of items"),
dat.recall.combined.m.n.syll %>%
mutate (filter = "Number of syllables/item"),
dat.recall.combined.m.n.words %>%
mutate (filter = "Number of words"),
dat.recall.combined.m.n.words %>%
mutate (filter = "Proportion of words among vocalizations"),
dat.recall.combined.m.n.part.words %>%
mutate (filter = "Number of part-words"),
dat.recall.combined.m.n.part.words %>%
mutate (filter = "Proportion of part-words among vocalizations"),
dat.recall.combined.m.p.words.part.words %>%
mutate (filter = "Proportion of part-words among words and part-words" ),
dat.recall.combined.m.forward.tps %>%
mutate (filter = "Forward TPs"),
dat.recall.combined.m.forward.tps.actual.vs.expected %>%
mutate (filter = "Actual vs. Expected Forward TPs"),
dat.recall.combined.m.backward.tps %>%
mutate (filter = "Backward TPs"),
dat.recall.combined.m.n.high.tp.chunk %>%
mutate (filter = "Number of High TP chunks"),
dat.recall.combined.m.p.high.tp.chunk %>%
mutate (filter = "Proportion of High TP chunks among productions"),
dat.recall.combined.m.n.low.tp.chunk %>%
mutate (filter = "Number of Low TP chunks"),
dat.recall.combined.m.p.low.tp.chunk %>%
mutate (filter = "Number of Low TP chunks among productions"),
dat.recall.combined.m.p.high.tp.chunk.low.tp.chunk %>%
mutate (filter = "Proportion of High TP chunks among High and Low TP chunks"),
dat.recall.combined.m.p.correct.initial.syll %>%
mutate (filter = "Proportion of items with correct initial syllables"),
dat.recall.combined.m.p.correct.final.syll %>%
mutate (filter = "Proportion of items with correct final syllables"),
dat.recall.combined.m.p.correct.initial.or.final.syll %>%
mutate (filter = "Proportion of items with correct initial or final syllables")
)
dat.recall.combined.m.n.items.n.syll %>%
dplyr::select (-c("filter")) %>%
rename ("$p_{cont vs. segm}$"="d") %>%
kable (caption = "Various analyses pertaining to the productions as well as test against their chances levels. Number of items produced, their numbers of syllables, number of words, number of part-words (chance level: 0), proportion  of words among productions, proportion of part-words among productions, proportion of words among words and part-words (chance level 50%), average forward TPs (chance level: 1/12), difference between positionally expected and actual TPs, average backward TPS. CHUNKS ", booktabs = TRUE, escape = FALSE) %>%
#     kable_styling() %>%
pack_rows(index = make.pack.index (dat.recall.combined.m.n.items.n.syll$filter))
dat.recall.combined.m.n.items.n.syll <-
bind_rows(
dat.recall.combined.m.n.items %>%
mutate (filter = "Number of items"),
dat.recall.combined.m.n.syll %>%
mutate (filter = "Number of syllables/item"),
dat.recall.combined.m.n.words %>%
mutate (filter = "Number of words"),
dat.recall.combined.m.n.words %>%
mutate (filter = "Proportion of words among vocalizations"),
dat.recall.combined.m.n.part.words %>%
mutate (filter = "Number of part-words"),
dat.recall.combined.m.n.part.words %>%
mutate (filter = "Proportion of part-words among vocalizations"),
dat.recall.combined.m.p.words.part.words %>%
mutate (filter = "Proportion of part-words among words and part-words" ),
dat.recall.combined.m.forward.tps %>%
mutate (filter = "Forward TPs"),
dat.recall.combined.m.forward.tps.actual.vs.expected %>%
mutate (filter = "Actual vs. Expected Forward TPs"),
dat.recall.combined.m.backward.tps %>%
mutate (filter = "Backward TPs"),
dat.recall.combined.m.n.high.tp.chunk %>%
mutate (filter = "Number of High TP chunks"),
dat.recall.combined.m.p.high.tp.chunk %>%
mutate (filter = "Proportion of High TP chunks among productions"),
dat.recall.combined.m.n.low.tp.chunk %>%
mutate (filter = "Number of Low TP chunks"),
dat.recall.combined.m.p.low.tp.chunk %>%
mutate (filter = "Number of Low TP chunks among productions"),
dat.recall.combined.m.p.high.tp.chunk.low.tp.chunk %>%
mutate (filter = "Proportion of High TP chunks among High and Low TP chunks"),
dat.recall.combined.m.p.correct.initial.syll %>%
mutate (filter = "Proportion of items with correct initial syllables"),
dat.recall.combined.m.p.correct.final.syll %>%
mutate (filter = "Proportion of items with correct final syllables"),
dat.recall.combined.m.p.correct.initial.or.final.syll %>%
mutate (filter = "Proportion of items with correct initial or final syllables")
)
dat.recall.combined.m.n.items.n.syll %>%
dplyr::select (-c("filter")) %>%
rename ("$p_{cont\ vs.\ segm}$"="d") %>%
kable (caption = "Various analyses pertaining to the productions as well as test against their chances levels. Number of items produced, their numbers of syllables, number of words, number of part-words (chance level: 0), proportion  of words among productions, proportion of part-words among productions, proportion of words among words and part-words (chance level 50%), average forward TPs (chance level: 1/12), difference between positionally expected and actual TPs, average backward TPS. CHUNKS ", booktabs = TRUE, escape = FALSE) %>%
#     kable_styling() %>%
pack_rows(index = make.pack.index (dat.recall.combined.m.n.items.n.syll$filter))
dat.recall.unattested.m.city
dat.recall.city %>%
filter (!is_part_of_stream)
xlsx::write.xlsx (bind_rows(dat.recall.unattested.m),
file="output/segmentation_recall_unattested.xlsx",
row.names=FALSE,
sheetName="Ns",
append=FALSE)
xlsx::write.xlsx (bind_rows(dat.recall.unattested.m) %>%
data.frame,
file="output/segmentation_recall_unattested.xlsx",
row.names=FALSE,
sheetName="Ns",
append=FALSE)
if (ANALYZED.DATA.SETS["CITY"]){
dat.recall.city %>%
filter (!is_part_of_stream) %>%
xlsx::write.xlsx (.,
file="output/segmentation_recall_unattested.xlsx",
row.names=FALSE,
sheetName="city",
append=TRUE)
}
if (ANALYZED.DATA.SETS["TESTABLE"]){
dat.all.recall.items.tstbl.with.candidates %>%
filter (!is_part_of_stream) %>%
xlsx::write.xlsx (.,
file="output/segmentation_recall_unattested.xlsx",
row.names=FALSE,
sheetName="tstbl",
append=TRUE)
}
